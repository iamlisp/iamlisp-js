(defun list (. xargs)
  (.reduce (.reverse xargs)
           #(new js/ListNode %2 %1)
           js/NilList))

(defun head (xs) (get "head" xs))
(defun tail (xs) (get "tail" xs))
(defun list* (x xs) (new js/ListNode x xs))
(def +: list*)

(def Nil (list))
(assert (eq? Nil (list)))

(defun empty? (xs) (eq? xs Nil))
(assert (empty? Nil))
(assert (not (empty? (list 1 2 3))))

(defun foldl (f acc xs)
  (if (empty? xs)
      acc
      (foldl f (f (head xs) acc) (tail xs))))

(defun foldr (f acc xs)
  (if (empty? xs)
      acc
      (f (head xs)
         (foldr f acc (tail xs)))))

(defun size (v)
  (where (type (typeof v)
          size-attr "length")
    (defun size-string (str) (get "length" str))
    (defun size-array (arr) (get "length" arr))
    (defun size-list (xs)
      (defun iter (s xs)
        (cond ((empty? xs) s) 
              ((iter (inc s) (tail xs)))))
      (iter 0 xs))
    (cond ((eq? type "String") (size-string v))
          ((eq? type "Array") (size-array v))
          ((eq? type "List") (size-list v))
          (null))))
(assert (eq? (size "Hello") 5))
(assert (eq? (size '(1 2 3)) 3))
(assert (eq? (size (list 1 2 3)) 3))
(assert (eq? (size Nil) 0))

(defun nth (i xs)
  (defun nth-string (i str) (get i str))
  (defun nth-array (i arr) (get i arr))
  (defun nth-list (i str)
    (cond ((empty? xs) null)
          ((zero? i) (head xs))
          ((nth (dec i) (tail xs)))))
  (cond ((eq? (typeof xs) "String")
         (nth-string i xs))
        ((eq? (typeof xs) "Array")
         (nth-array i xs))
        ((eq? (typeof xs) "List")
         (nth-list i xs))
        (null)))
(assert (eq? (nth 0 (list 10 20 30)) 10))
(assert (eq? (nth 1 (list 10 20 30)) 20))
(assert (eq? (nth 1 "bar") "a"))
(assert (eq? (nth 2 "bar") "r"))
(assert (eq? (nth 2 '(10 20 30) 30)))

(defun :: (. xss)
  (defun iter (xs ys)
    (cond ((empty? xs) ys)
          ((iter (tail xs) (+: (head xs) ys)))))
  (.reduce xss 
           (lambda (xs ys) (iter (reverse xs) ys))
           Nil))

(defun until (from to)
  (defun iter (i res)
    (cond ((>= i to) (reverse res))
          ((iter (inc i) (+: i res)))))
  (iter from Nil))

(defun init (xs)
  (cond ((empty? xs) null)
        ((empty? (tail xs)) Nil)
        ((+: (head xs) (init (tail xs))))))

(defun last (xs)
  (cond ((empty? xs) null)
        ((empty? (tail xs)) (head xs))
        ((last (tail xs)))))

(defun reverse (xs)
  (defun iter (l res)
    (cond ((empty? l) res)
          ((iter (tail l) (+: (head l) res)))))
  (iter xs Nil))

(defun take (k xs)
  (defun iter (ys l res)
    (cond ((or (zero? l) (empty? ys)) (reverse res))
          ((iter (tail ys) (dec l) (+: (head ys) res)))))
  (iter xs k Nil))

(defun drop (k xs)
  (cond ((or (zero? k) (empty? xs)) xs)
        ((drop (dec k) (tail xs)))))

(defun splitAt (k xs) (list (take xs k) (drop xs k)))

(defun patch (k ys l xs)
  (:: (take k xs)
      ys
      (drop (+ k l) xs)))

(defun map-rec (f xs)
  (cond ((empty? xs) Nil)
        ((+: (f (head xs)) (map-rec f (tail xs))))))

(defun map (f xs)
  (defun iter (xs res)
    (cond ((empty? xs) (reverse res))
          ((iter (tail xs) 
                 (+: (f (head xs)) res)))))
  (iter xs Nil))

(defun filter (f xs)
  (defun iter (xs res)
    (cond ((empty? xs) (reverse res))
          ((f (head xs)) (iter (tail xs) 
                               (+: (head xs) res))) 
          ((iter (tail xs) res))))
  (iter xs Nil))

(defun reduce (f initial xs)
  (defun iter (xs res)
    (cond ((empty? xs) res)
          ((iter (tail xs)
                 (f res (head xs))))))
  (iter xs initial))

(defun flatmap (f xs)
  (defun iter (xs res)
    (cond ((empty? xs) res)
          ((iter (tail xs) (:: res (f (head xs)))))))
  (iter xs Nil))

(defun indices (xs) (until 0 (size xs)))

(defun mergesort (xs)
  (defun merge (xs ys)
    (cond ((empty? xs) ys)
          ((empty? ys) xs)
          ((cond ((< (head xs) (head ys))
                  (+: (head xs)
                      (merge (tail xs) ys)))
                 ((+: (head ys)
                  (merge xs
                         (tail ys))))))))
  (where (pivot (// (size xs) 2))
         (cond ((zero? pivot) xs)
               ((merge (mergesort (take xs pivot))
                       (mergesort (drop xs pivot)))))))

(defun chunk (xs n)
    (defun iter (xs res)
      (cond ((empty? xs) res)
            ((iter (drop n xs) (+: (take n xs) res)))))
    (reverse (iter xs Nil)))

(def Nil (list))

(defun empty? (xs) (eq? xs Nil))

(defun :: (. xss)
  (defun iter (xs ys)
    (cond ((empty? xs) ys)
          ((iter (tail xs) (+: ys (head xs))))))
  (.reduce xss 
           (lambda (xs ys) (iter (reverse xs) ys))
           Nil))

(defun until (from to)
  (defun iter (i res)
    (cond ((eq? i to) (reverse res))
          ((iter (inc i) (+: res i)))))

  (cond ((> from to) Nil)
        ((iter from Nil))))

(defun init (xs)
  (cond ((empty? xs) null)
        ((empty? (tail xs)) Nil)
        ((+: (init (tail xs)) (head xs)))))

(defun last (xs)
  (cond ((empty? xs) null)
        ((empty? (tail xs)) (head xs))
        ((last (tail xs)))))

(defun reverse (xs)
  (defun iter (l res)
    (cond ((empty? l) res)
          ((iter (tail l) (+: res (head l))))))
  (iter xs Nil))

(defun take-rec (xs k)
  (cond ((or (zero? k) (empty? xs)) xs)
        ((+: (take-rec (tail xs) (dec k)) (head xs)))))

(defun take (xs k)
  (defun iter (ys l res)
    (cond ((or (zero? l) (empty? ys)) (reverse res))
          ((iter (tail ys) (dec l) (+: res (head ys))))))
  (iter xs k Nil))

(defun drop (xs k)
  (cond ((or (zero? k) (empty? xs)) xs)
        ((drop (tail xs) (dec k)))))

(defun splitAt (xs k) (list (take xs k) (drop xs k)))

(defun patch (xs k ys l)
  (:: (take xs k)
      ys
      (drop xs (+ k l))))

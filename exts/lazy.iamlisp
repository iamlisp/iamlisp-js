(defmacro defer (xs)
  (where (executed? false
          result null)
    ^{"deferred" true} (lambda ()
      (cond ((not executed?) (set! result xs  
                                   executed? true)))
      result)))

(defun deferred? (sxs) (and (eq? (typeof sxs) "Lambda")
                            (eq? (typeof (get-meta sxs)) "Map")
                            (get "deferred" (get-meta sxs))))

(defun raise (sxs) (cond ((deferred? sxs) (sxs)) (sxs)))

(defmacro scons (x y) (lambda (z) (z x (defer y))))
(defun scar (xs) (xs (lambda (x y) x)))
(defun scdr (xs) (xs (lambda (x y) (raise y))))

(def SNil (scons null null))
(defun sempty? (sxs) (eq? sxs SNil))

(defun srepeat (s) (scons s (srepeat s)))
(defun srange (from to) (cond ((> from to) SNil)
                              ((scons from (srange (inc from) to)))))

(defun stake (n sxs) (cond ((> n 0) 
                            (scons (scar sxs) (stake (dec n) (scdr sxs)))) 
                           (SNil)))

(defun sprint (sxs)
  (def items ())
  (defun iter (sxs left)
    (cond ((zero? left) (.push items "..."))
          ((not (sempty? sxs)) 
           (begin (.push items (scar sxs))
                  (iter (scdr sxs) (dec left))))))
  (iter sxs 100)
  (print (+ "[" (.join items " ") "]")))
